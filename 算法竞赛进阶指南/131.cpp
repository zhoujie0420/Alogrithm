//
// Created by ZhouJie on 2022/7/13.
//  直方图是由在公共基线处对齐的一系列矩形组成的多边形。
//
//矩形具有相等的宽度，但可以具有不同的高度。
//
//例如，图例左侧显示了由高度为 2,1,4,5,1,3,3 的矩形组成的直方图，矩形的宽度都为 1：
//
//2559_1.jpg
//
//通常，直方图用于表示离散分布，例如，文本中字符的频率。
//
//现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。
//
//图例右图显示了所描绘直方图的最大对齐矩形。
//
//输入格式
//输入包含几个测试用例。
//
//每个测试用例占据一行，用以描述一个直方图，并以整数 n 开始，表示组成直方图的矩形数目。
//
//然后跟随 n 个整数 h1，…，hn。
//
//这些数字以从左到右的顺序表示直方图的各个矩形的高度。
//
//每个矩形的宽度为 1。
//
//同行数字用空格隔开。
//
//当输入用例为 n=0 时，结束输入，且该用例不用考虑。
//
//输出格式
//对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。
//
//每个数据占一行。
//
//请注意，此矩形必须在公共基线处对齐。
//
//数据范围
//1≤n≤100000,
//0≤hi≤1000000000
//输入样例：
//7 2 1 4 5 1 3 3
//4 1000 1000 1000 1000
//0
//输出样例：
//8
//4000
 #include <bits/stdc++.h>
#include <stack>

using namespace std;

 const int N = 1e5 + 10;
//
// int n;
// int res;
// int a[N];
//
// int main() {
//     while (cin >> n, n) {
//         res = 0;
//         for (int i = 0; i < n; i++) {
//             cin >> a[i];
//         }
//         for (int i = 0; i < n; i++) {
//             int cnt1 = 0, cnt2 = 0;
//             int j = i - 1;
//             while (j >= 0 && a[i] <= a[j]) {
//                 j--;
//                 cnt1++;
//             }
//             j = i + 1;
//             while (a[j] >= a[i] && j < n) {
//                 j++;
//                 cnt2++;
//             }
//             res = max(res, (cnt1 + cnt2 + 1) * a[i]);
//         }
//         cout << res << endl;
//     }
//     return 0;
// }
typedef long long LL;
int h[N];

int main(){
    stack<int> r,l;
    int n;
    while(cin >> n, n){
        for (int i = 1; i <= n; ++i) cin >> h[i];
        h[0] = h[n+1] = -1;
        l.push(0);
        for (int i = 1; i <= n; ++i) {
            if(h[i] < h[l.top()]) l.push(i);
        }
        r.push(n+1);
        for(int i = n;i > 0;--i){
            if(h[i] < h[r.top()]) r.push(i);
        }

    }

}

