//
// Created by ZhouJie on 2022/5/6 14:59.
//一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。
//
//现在要进行 m 个操作，操作共有两种：
//
//M a b，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
//Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中；
//输入格式
//第一行输入整数 n 和 m。
//
//接下来 m 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。
//
//输出格式
//对于每个询问指令 Q a b，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 Yes，否则输出 No。
//
//每个结果占一行。



/*给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。

现在要进行 m 个操作，操作共有三种：

C a b，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
Q1 a b，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；
Q2 a，询问点 a 所在连通块中点的数量；
输入格式
第一行输入整数 n 和 m。

接下来 m 行，每行包含一个操作指令，指令为 C a b，Q1 a b 或 Q2 a 中的一种。

输出格式
对于每个询问指令 Q1 a b，如果 a 和 b 在同一个连通块中，则输出 Yes，否则输出 No。

对于每个询问指令 Q2 a，输出一个整数表示点 a 所在连通块中点的数量

每个结果占一行。*/


//添加一个操作：返回集合的元素个数
//  只需要在维护一个size[]  这个数组只对父节点有意义 ， 当我们实行合并操作时  只需要size[a] += size[b]即可



/*并查集：
1.将两个集合合并
2.询问两个元素是否在一个集合当中
时间复杂度近乎O(1)
基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点储存它的父节点，p[x]表示x的父节点。
问题1：如何判断树根：if(p[x] == x)
问题2：如何求x的集合编号：while(p[x] != x) x = p[x];  (常用优化方法：路径压缩)
    路径压缩：当我们查找x的父节点时，不妨对其向上遍历的过程中进行对每个元素都指向父节点 真正实现O(1)
问题3：如何合并两个集合：px是x的集合编号，py是y的集合编号。p[x] = y;
*/
#include <bits/stdc++.h>

using namespace std;
const int N = 10006;
int n , m;
int p[N];
int find(int x){   //返回x的祖宗节点 + 路径压缩
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}
int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        p[i] = i;
    }
    while(m--) {
        int a, b;
        char op[2];
        cin >> op >> a >> b;
        if (op[0] == 'M') p[find(p[a])] = find(b);
        else {
            if (find(a) == find(b)) cout << "Yes" << endl;
            else cout << "No" << endl;
        }
    }
    return 0;
}